<!-- WEBFLOW EMBED CODE - Paste this in Webflow Custom Code -->
<div id="dots-map-container" style="width:100%;height:100%;position:relative;-webkit-mask-image:radial-gradient(circle at center,black 20%,transparent 100%),linear-gradient(to top,transparent,black 20%),linear-gradient(to bottom,transparent,black 20%);-webkit-mask-composite:source-in;mask-image:radial-gradient(circle at center,black 20%,transparent 100%),linear-gradient(to top,transparent,black 20%),linear-gradient(to bottom,transparent,black 20%);mask-composite:intersect">
  <canvas id="dotsCanvas" style="display:block;width:100%;height:100%"></canvas>
</div>

<script>
(function(){
const c=document.getElementById('dotsCanvas'),ctx=c.getContext('2d',{alpha:true});
const container=document.getElementById('dots-map-container');

// Set canvas resolution based on container size
function resizeCanvas(){
  const rect=container.getBoundingClientRect();
  c.width=rect.width;
  c.height=rect.height;
  if(dots.length>0)drawDots();
}
window.addEventListener('resize',resizeCanvas);
let dots=[],pulseDots=[],animating=new Set();
const originalW=1110,originalH=1400; // Original coordinate space

// Get uniform scale and offsets
function getScale(){
  const scaleX=c.width/originalW;
  const scaleY=c.height/originalH;
  const scale=Math.min(scaleX,scaleY); // Use uniform scale to maintain aspect ratio
  
  // Align to left, center vertically
  const offsetX=0; // Left-aligned
  const offsetY=(c.height-originalH*scale)/2; // Vertically centered
  
  return {scale,offsetX,offsetY};
}

// Load coordinate data (host dots-data-with-radius.json on your server/CDN)
fetch('https://code.anton-atom.com/count/westgass/dots-data-with-radius.json')
  .then(r=>r.json())
  .then(coords=>{
    for(let i=0;i<coords.length;i+=3)dots.push({x:coords[i],y:coords[i+1],r:coords[i+2]});
    
    // Find pulse dots by their coordinates (from original SVG)
    const pulseCoords=[
      [990,250],    // Norway
      [940,440],    // Switzerland
      [940,390],    // Germany
      [1180,970],    // Uganda
      [1190,520],    // Turkey
      [1810,710],    // Bangladesh
      [1940,680],    // China
      [870,370],    // UK
      [880,450],    // France
      [920,380],    // Netherlands
    ];
    pulseCoords.forEach(([px,py])=>{
      const pd=dots.find(d=>d.x===px&&d.y===py);
      if(pd)pulseDots.push(pd);
    });
    
    console.log(`Found ${pulseDots.length} pulse dots`);
    
    resizeCanvas();
    initPulse();
  });

function drawDots(){
  const {scale,offsetX,offsetY}=getScale();
  
  ctx.clearRect(0,0,c.width,c.height);
  ctx.fillStyle='#48C4D5';
  dots.forEach(d=>{
    ctx.beginPath();
    ctx.arc(d.x*scale+offsetX,d.y*scale+offsetY,d.r*scale,0,Math.PI*2);
    ctx.fill();
  });
  // Draw pulse dots with their original radius
  ctx.fillStyle='#49C4D5';
  pulseDots.forEach(d=>{
    ctx.beginPath();
    ctx.arc(d.x*scale+offsetX,d.y*scale+offsetY,d.r*scale,0,Math.PI*2);
    ctx.fill();
  });
}

// Track active ripples with their start times
const activeRipples=new Map();

// Single animation loop for all ripples
let animationRunning=false;
function animate(){
  if(activeRipples.size===0){
    animationRunning=false;
    return;
  }
  
  const now=Date.now();
  const {scale,offsetX,offsetY}=getScale();
  
  ctx.clearRect(0,0,c.width,c.height);
  drawDots();
  
  // Process all active ripples
  activeRipples.forEach((startTime,pd)=>{
    const t=(now-startTime)/1000;
    if(t>2){
      activeRipples.delete(pd);
      return;
    }
    
    // Pulse center dot
    if(t<1.2){
      const sc=t<0.36?1+Math.sin(t*Math.PI/0.36)*0.2:1;
      const clr=t<0.72?lerpColor('#49C4D5','#632C8F',Math.sin(t*Math.PI/0.72)):'#49C4D5';
      ctx.fillStyle=clr;
      ctx.beginPath();
      ctx.arc(pd.x*scale+offsetX,pd.y*scale+offsetY,pd.r*scale*sc,0,Math.PI*2);
      ctx.fill();
    }
    
    // Ripple wave
    dots.forEach(d=>{
      if(d===pd)return;
      const dist=Math.sqrt((d.x-pd.x)**2+(d.y-pd.y)**2);
      if(dist>100)return;
      
      const delay=dist/0.15/1000;
      if(t<delay||t>delay+0.4)return;
      
      const wt=(t-delay)/0.4;
      const int=(1-dist/100)**2;
      const sc=wt<0.5?1+(1.02+int*0.18-1)*Math.sin(wt*Math.PI):1;
      const clr=wt<0.5?lerpColor('#48C4D5','#31AABB',Math.sin(wt*Math.PI)):'#48C4D5';
      
      ctx.fillStyle=clr;
      ctx.beginPath();
      ctx.arc(d.x*scale+offsetX,d.y*scale+offsetY,d.r*scale*sc,0,Math.PI*2);
      ctx.fill();
    });
  });
  
  requestAnimationFrame(animate);
}

function ripple(pd){
  activeRipples.set(pd,Date.now());
  if(!animationRunning){
    animationRunning=true;
    animate();
  }
}

function lerpColor(c1,c2,t){
  // Handle rgba and hex colors
  const parse=c=>{
    if(c.startsWith('#')){
      return{r:parseInt(c.slice(1,3),16),g:parseInt(c.slice(3,5),16),b:parseInt(c.slice(5,7),16),a:1};
    }else{
      const m=c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      return m?{r:+m[1],g:+m[2],b:+m[3],a:m[4]?+m[4]:1}:{r:0,g:0,b:0,a:1};
    }
  };
  const a=parse(c1),b=parse(c2);
  const r=Math.round(a.r+(b.r-a.r)*t);
  const g=Math.round(a.g+(b.g-a.g)*t);
  const bl=Math.round(a.b+(b.b-a.b)*t);
  const al=a.a+(b.a-a.a)*t;
  return `rgba(${r},${g},${bl},${al})`;
}

function initPulse(){
  pulseDots.forEach((pd,i)=>{
    setTimeout(()=>{
      ripple(pd);
      (function schedule(){
        // Adjust timing here: (MIN + Math.random() * RANGE) * 1000
        // Current: 3-8 seconds (too aggressive)
        // Try: 8-15 seconds for calmer effect
        setTimeout(()=>{ripple(pd);schedule();},(8+Math.random()*8)*1000);
      })();
    },Math.random()*5000); // Initial delay: 0-5 seconds
  });
}
// TEMPORARY: Click canvas to find dot coordinates
c.addEventListener('click',e=>{
  const rect=c.getBoundingClientRect();
  const {scale,offsetX,offsetY}=getScale();
  const x=Math.round((e.clientX-rect.left-offsetX)/scale);
  const y=Math.round((e.clientY-rect.top-offsetY)/scale);
  console.log(`Clicked coordinates: [${x},${y}]`);
  const nearDot=dots.find(d=>Math.abs(d.x-x)<10&&Math.abs(d.y-y)<10);
  if(nearDot)console.log(`Found dot at: [${nearDot.x},${nearDot.y}]`);
});
})();
</script>
